<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TechFest Camera Filters</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }
        
        #container {
            position: relative;
            width: 640px;
            max-width: 90vw;
            background: transparent;
            border-radius: 15px;
            padding: 0;
            box-shadow: none;
        }
        
        #videoContainer {
            position: relative;
            width: 100%;
        }
        
        #webcam {
            display: none; /* Hide original video */
        }
        
        #canvas {
            width: 100%;
            border-radius: 10px;
            display: block;
        }
        
        #frameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #filterButtons {
            position: absolute;
            bottom: 120px;
            left: 0;
            right: 0;
            display: flex;
            gap: 15px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 15px 20px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        #filterButtons::-webkit-scrollbar {
            display: none;
        }
        
        .filter-item {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .filter-item:active {
            transform: scale(0.95);
        }
        
        .filter-preview {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }
        
        .filter-item.active .filter-preview {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.5);
        }
        
        .filter-name {
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .filter-item.active .filter-name {
            color: #ff6b6b;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .filter-btn {
            background: #667eea;
            color: white;
        }
        
        .filter-btn:hover {
            background: #764ba2;
            transform: scale(1.05);
        }
        
        .filter-btn.active {
            background: #ff6b6b;
            box-shadow: 0 5px 15px rgba(255,107,107,0.4);
        }
        
        #captureBtn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: white;
            border: 5px solid rgba(255, 255, 255, 0.5);
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        #captureBtn:active {
            transform: translateX(-50%) scale(0.9);
        }
        
        #preview {
            margin-top: 20px;
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 10px;
            display: none;
        }
        
        #preview.show {
            display: block;
        }
        
        #preview img {
            max-width: 100%;
            border-radius: 10px;
            margin-top: 10px;
        }
        
        #downloadBtn {
            background: #339af0;
            color: white;
            margin-top: 10px;
            display: none;
        }
        
        .frame-option {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        
        .frame-btn {
            padding: 10px 20px;
            background: #20c997;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .frame-btn:hover {
            background: #12b886;
        }
        
        .frame-btn.active {
            background: #ff6b6b;
        }
        
        .accessory-option {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }
        
        .accessory-btn {
            padding: 10px 20px;
            background: #fa5252;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .accessory-btn:hover {
            background: #e03131;
        }
        
        .accessory-btn.active {
            background: #ff6b6b;
            box-shadow: 0 5px 15px rgba(255,107,107,0.5);
        }
        
        .controls {
            margin: 15px 0;
            text-align: center;
        }
        
        label {
            color: #333;
            font-weight: bold;
            margin-right: 10px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        #status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        #status.loading {
            background: #fff3bf;
            color: #996300;
        }
        
        #status.ready {
            background: #d3f9d8;
            color: #2b8a3e;
        }
    </style>
</head>
<body>
    <h1>üé≠ TechFest AR Camera Filters</h1>
    
    <div id="status" class="loading">‚è≥ Loading face detection...</div>
    
    <div id="container">
        <div id="videoContainer">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <canvas id="frameOverlay"></canvas>
        </div>
        
        <div id="filterButtons">
            <div class="filter-item active" onclick="setFilter('none', this)">
                <div class="filter-preview">üì∑</div>
                <div class="filter-name">Original</div>
            </div>
            <div class="filter-item" onclick="setFilter('grayscale', this)">
                <div class="filter-preview">‚ö´</div>
                <div class="filter-name">B&W</div>
            </div>
            <div class="filter-item" onclick="setFilter('sepia', this)">
                <div class="filter-preview">üü§</div>
                <div class="filter-name">Vintage</div>
            </div>
            <div class="filter-item" onclick="setFilter('neon', this)">
                <div class="filter-preview">üíú</div>
                <div class="filter-name">Neon</div>
            </div>
            <div class="filter-item" onclick="setFilter('cyberpunk', this)">
                <div class="filter-preview">üåÉ</div>
                <div class="filter-name">Cyber</div>
            </div>
            <div class="filter-item" onclick="setFilter('glitch', this)">
                <div class="filter-preview">‚ö°</div>
                <div class="filter-name">Glitch</div>
            </div>
            <div class="filter-item" onclick="toggleCap('techfest', this)">
                <div class="filter-preview">üß¢</div>
                <div class="filter-name">Cap</div>
            </div>
            <div class="filter-item" onclick="toggleFrame(true, this)">
                <div class="filter-preview">üñºÔ∏è</div>
                <div class="filter-name">Frame</div>
            </div>
        </div>
        
        <button id="captureBtn" onclick="capturePhoto()">üì∏</button>
        
        <div id="preview"></div>
        <button id="downloadBtn" onclick="downloadPhoto()">üíæ Download Image</button>
    </div>

    <script>
        let video = document.getElementById('webcam');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let frameCanvas = document.getElementById('frameOverlay');
        let frameCtx = frameCanvas.getContext('2d');
        let currentFilter = 'none';
        let filterIntensity = 1.0;
        let capturedImage = null;
        let showFrame = true;
        let showCap = 'techfest';
        let faceDetection = null;
        let isModelLoaded = false;
        let lastFacePosition = null;
        let smoothedPosition = null;
        const smoothingFactor = 0.3; // Lower = smoother but slower response
        
        // Load face detection model
        async function loadFaceDetection() {
            try {
                faceDetection = new FaceDetection({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
                    }
                });
                
                faceDetection.setOptions({
                    model: 'short',
                    minDetectionConfidence: 0.3,
                    selfieMode: true
                });
                
                faceDetection.onResults(onFaceDetectionResults);
                
                await faceDetection.initialize();
                isModelLoaded = true;
                console.log('‚úÖ Face detection loaded!');
                document.getElementById('status').textContent = '‚úÖ Face detection ready! Cap will appear.';
                document.getElementById('status').className = 'ready';
            } catch (err) {
                console.error('‚ùå Face detection failed:', err);
                document.getElementById('status').textContent = '‚úÖ Cap showing at center (face tracking disabled)';
                document.getElementById('status').className = 'ready';
                // Fallback: use center of screen
                isModelLoaded = false;
            }
        }
        
        function onFaceDetectionResults(results) {
            if (results.detections && results.detections.length > 0) {
                const detection = results.detections[0];
                const newPosition = detection.boundingBox;
                
                // Smooth the position to reduce jitter
                if (smoothedPosition) {
                    smoothedPosition = {
                        xCenter: smoothedPosition.xCenter * (1 - smoothingFactor) + newPosition.xCenter * smoothingFactor,
                        yCenter: smoothedPosition.yCenter * (1 - smoothingFactor) + newPosition.yCenter * smoothingFactor,
                        width: smoothedPosition.width * (1 - smoothingFactor) + newPosition.width * smoothingFactor,
                        height: smoothedPosition.height * (1 - smoothingFactor) + newPosition.height * smoothingFactor
                    };
                } else {
                    smoothedPosition = newPosition;
                }
                
                lastFacePosition = smoothedPosition;
            }
        }
        
        // Start webcam
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    } 
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    frameCanvas.width = video.videoWidth;
                    frameCanvas.height = video.videoHeight;
                    
                    // Start rendering
                    requestAnimationFrame(render);
                };
            } catch (err) {
                alert('Camera access denied! Please allow camera permissions.');
                console.error(err);
            }
        }
        
        // Main render loop
        async function render() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Draw mirrored video to canvas
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                ctx.restore();
                
                // Apply filter
                if (currentFilter !== 'none') {
                    applyFilter();
                }
                
                // Send frame to face detection
                if (isModelLoaded && faceDetection && showCap !== 'none') {
                    await faceDetection.send({image: video});
                }
                
                // Draw cap based on last detected position
                if (showCap !== 'none') {
                    drawCapOnFace();
                }
                
                // Draw frame overlay
                if (showFrame) {
                    drawTechFestFrame();
                } else {
                    frameCtx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
                }
            }
            
            requestAnimationFrame(render);
        }
        
        // Draw cap on detected face
        function drawCapOnFace() {
            let capX, capY, capWidth, capHeight;
            
            if (lastFacePosition) {
                // Use detected face position with improved accuracy
                const face = lastFacePosition;
                const videoWidth = canvas.width;
                const videoHeight = canvas.height;
                
                // Calculate face dimensions
                const faceWidth = face.width * videoWidth;
                const faceHeight = face.height * videoHeight;
                
                // Get face center position (already normalized 0-1)
                const faceCenterX = face.xCenter * videoWidth;
                const faceCenterY = face.yCenter * videoHeight;
                
                // Mirror X position for selfie mode
                const mirroredX = videoWidth - faceCenterX;
                
                // Cap sizing - make it proportional to face
                capWidth = faceWidth * 2.0;
                capHeight = capWidth * 0.6;
                
                // Position cap above face center
                // Move up by face height to place on forehead/top of head
                capX = mirroredX - capWidth / 2;
                capY = faceCenterY - faceHeight * 0.95 - capHeight * 0.15;
                
            } else {
                // Fallback: center-top position
                capWidth = canvas.width * 0.25;
                capHeight = capWidth * 0.55;
                capX = canvas.width / 2 - capWidth / 2;
                capY = canvas.height * 0.12;
            }
            
            drawTechFestCap(capX, capY, capWidth, capHeight);
        }
        
        // Detect face and draw cap
        async function detectAndDrawCap() {
            try {
                const faces = await faceDetector.estimateFaces(canvas, { flipHorizontal: false });
                
                if (faces.length > 0) {
                    const face = faces[0];
                    const keypoints = face.keypoints;
                    
                    // Get forehead position (top of head)
                    const forehead = keypoints[10]; // Top of head landmark
                    const leftTemple = keypoints[234];
                    const rightTemple = keypoints[454];
                    
                    if (forehead && leftTemple && rightTemple) {
                        const faceWidth = Math.abs(rightTemple.x - leftTemple.x);
                        const capWidth = faceWidth * 1.8;
                        const capHeight = capWidth * 0.6;
                        const capX = forehead.x - capWidth / 2;
                        const capY = forehead.y - capHeight * 0.9;
                        
                        drawTechFestCap(capX, capY, capWidth, capHeight);
                    }
                }
            } catch (err) {
                console.error('Face detection error:', err);
            }
        }
        
        // Draw TechFest branded cap
        function drawTechFestCap(x, y, width, height) {
            ctx.save();
            
            // === BRIM (Front visor) ===
            const brimWidth = width * 0.9;
            const brimHeight = height * 0.35;
            const brimY = y + height * 0.65;
            
            // Brim shadow underneath
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 10;
            
            // Brim gradient (top to bottom - lighter to darker)
            const brimGradient = ctx.createLinearGradient(x + width/2, brimY - brimHeight/2, x + width/2, brimY + brimHeight/2);
            brimGradient.addColorStop(0, '#2a2a2a');
            brimGradient.addColorStop(0.5, '#1a1a1a');
            brimGradient.addColorStop(1, '#0a0a0a');
            
            ctx.fillStyle = brimGradient;
            ctx.beginPath();
            ctx.ellipse(x + width/2, brimY, brimWidth/2, brimHeight/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Brim stitching detail
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(x + width/2, brimY, brimWidth/2 - 5, brimHeight/2 - 3, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.shadowColor = 'transparent';
            
            // === CROWN (Main dome) ===
            const crownRadius = width * 0.45;
            const crownCenterY = y + height * 0.38;
            
            // Crown gradient (3D sphere effect)
            const crownGradient = ctx.createRadialGradient(
                x + width/2 - crownRadius * 0.2, crownCenterY - crownRadius * 0.2, crownRadius * 0.1,
                x + width/2, crownCenterY, crownRadius
            );
            crownGradient.addColorStop(0, '#3a3a3a');
            crownGradient.addColorStop(0.4, '#1a1a1a');
            crownGradient.addColorStop(1, '#000000');
            
            ctx.fillStyle = crownGradient;
            ctx.beginPath();
            ctx.ellipse(x + width/2, crownCenterY, crownRadius * 0.85, crownRadius * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Crown panels (segmented look)
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 6) * i - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(x + width/2, crownCenterY - crownRadius * 0.6);
                ctx.lineTo(
                    x + width/2 + Math.cos(angle) * crownRadius * 0.7,
                    crownCenterY + Math.sin(angle) * crownRadius * 0.6
                );
                ctx.stroke();
            }
            
            // === FRONT PANEL (Neon green logo area) ===
            const panelWidth = width * 0.55;
            const panelHeight = height * 0.5;
            const panelY = crownCenterY + height * 0.05;
            
            // Panel gradient (3D curved effect)
            const panelGradient = ctx.createRadialGradient(
                x + width/2, panelY - panelHeight * 0.1, panelWidth * 0.2,
                x + width/2, panelY, panelWidth * 0.5
            );
            panelGradient.addColorStop(0, '#e0ff40');
            panelGradient.addColorStop(0.5, '#c0ff00');
            panelGradient.addColorStop(1, '#a0d000');
            
            ctx.fillStyle = panelGradient;
            ctx.beginPath();
            ctx.ellipse(x + width/2, panelY, panelWidth/2, panelHeight/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Panel border/stitching
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(x + width/2, panelY, panelWidth/2, panelHeight/2, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner highlight for 3D effect
            const highlightGradient = ctx.createRadialGradient(
                x + width/2 - panelWidth * 0.15, panelY - panelHeight * 0.15, 0,
                x + width/2 - panelWidth * 0.15, panelY - panelHeight * 0.15, panelWidth * 0.3
            );
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = highlightGradient;
            ctx.beginPath();
            ctx.ellipse(x + width/2 - panelWidth * 0.1, panelY - panelHeight * 0.1, panelWidth * 0.25, panelHeight * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // === LOGO TEXT ===
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Text shadow for depth
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetY = 2;
            
            // "IEEE" text
            ctx.fillStyle = '#000000';
            ctx.font = `bold ${width * 0.075}px Arial, sans-serif`;
            ctx.fillText('IEEE', x + width/2, panelY - panelHeight * 0.15);
            
            // "TECHFEST" text
            ctx.font = `bold ${width * 0.095}px Arial, sans-serif`;
            ctx.fillText('TECHFEST', x + width/2, panelY + panelHeight * 0.08);
            
            ctx.shadowColor = 'transparent';
            
            // Underline accent
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + width * 0.32, panelY + panelHeight * 0.25);
            ctx.lineTo(x + width * 0.68, panelY + panelHeight * 0.25);
            ctx.stroke();
            
            // === TOP BUTTON ===
            const buttonRadius = width * 0.045;
            const buttonY = y + height * 0.12;
            
            // Button gradient
            const buttonGradient = ctx.createRadialGradient(
                x + width/2 - buttonRadius * 0.3, buttonY - buttonRadius * 0.3, 0,
                x + width/2, buttonY, buttonRadius
            );
            buttonGradient.addColorStop(0, '#e0ff40');
            buttonGradient.addColorStop(0.6, '#c0ff00');
            buttonGradient.addColorStop(1, '#a0d000');
            
            ctx.fillStyle = buttonGradient;
            ctx.beginPath();
            ctx.arc(x + width/2, buttonY, buttonRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Button border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // === EYELETS (Ventilation holes) ===
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            const eyeletPositions = [
                { x: width * 0.25, y: crownCenterY + height * 0.1 },
                { x: width * 0.75, y: crownCenterY + height * 0.1 }
            ];
            
            eyeletPositions.forEach(pos => {
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(x + pos.x, pos.y + i * height * 0.08, width * 0.012, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.restore();
        }
        
        function applyFilter() {
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            
            switch(currentFilter) {
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        let avg = (data[i] + data[i+1] + data[i+2]) / 3;
                        let gray = avg * filterIntensity;
                        let original = 1 - filterIntensity;
                        data[i] = data[i] * original + gray;
                        data[i+1] = data[i+1] * original + gray;
                        data[i+2] = data[i+2] * original + gray;
                    }
                    break;
                    
                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i+1], b = data[i+2];
                        let tr = (r * 0.393 + g * 0.769 + b * 0.189);
                        let tg = (r * 0.349 + g * 0.686 + b * 0.168);
                        let tb = (r * 0.272 + g * 0.534 + b * 0.131);
                        
                        data[i] = r * (1 - filterIntensity) + tr * filterIntensity;
                        data[i+1] = g * (1 - filterIntensity) + tg * filterIntensity;
                        data[i+2] = b * (1 - filterIntensity) + tb * filterIntensity;
                    }
                    break;
                    
                case 'neon':
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i+1], b = data[i+2];
                        data[i] = r * (1 - filterIntensity) + Math.min(255, r * 1.3) * filterIntensity;
                        data[i+1] = g * (1 - filterIntensity) + Math.min(255, g * 0.7) * filterIntensity;
                        data[i+2] = b * (1 - filterIntensity) + Math.min(255, b * 1.5) * filterIntensity;
                    }
                    break;
                    
                case 'cyberpunk':
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i+1], b = data[i+2];
                        data[i] = r * (1 - filterIntensity) + Math.min(255, r * 0.8 + 50) * filterIntensity;
                        data[i+1] = g * (1 - filterIntensity) + Math.min(255, g * 1.2) * filterIntensity;
                        data[i+2] = b * (1 - filterIntensity) + Math.min(255, b * 1.5) * filterIntensity;
                    }
                    break;
                    
                case 'glitch':
                    for (let i = 0; i < data.length; i += 4) {
                        if (Math.random() < 0.02 * filterIntensity) {
                            let offset = Math.floor(Math.random() * 50) * 4;
                            if (i + offset < data.length) {
                                data[i] = data[i + offset];
                            }
                            if (i - offset >= 0) {
                                data[i+2] = data[i - offset + 2];
                            }
                        }
                    }
                    break;
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function drawTechFestFrame() {
            frameCtx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
            
            const w = frameCanvas.width;
            const h = frameCanvas.height;
            const borderWidth = Math.max(30, w * 0.03);
            
            // Outer border - neon green
            frameCtx.strokeStyle = '#c0ff00';
            frameCtx.lineWidth = borderWidth;
            frameCtx.strokeRect(borderWidth/2, borderWidth/2, w - borderWidth, h - borderWidth);
            
            // Inner accent line
            frameCtx.strokeStyle = '#ffffff';
            frameCtx.lineWidth = 3;
            frameCtx.strokeRect(borderWidth + 5, borderWidth + 5, w - (borderWidth + 5) * 2, h - (borderWidth + 5) * 2);
            
            // Top banner background
            const bannerHeight = Math.max(80, h * 0.12);
            frameCtx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            frameCtx.fillRect(borderWidth, borderWidth, w - borderWidth * 2, bannerHeight);
            
            // Tech pattern background
            frameCtx.strokeStyle = 'rgba(192, 255, 0, 0.3)';
            frameCtx.lineWidth = 2;
            for (let i = 0; i < 10; i++) {
                frameCtx.beginPath();
                frameCtx.moveTo(borderWidth + i * 40, borderWidth);
                frameCtx.lineTo(borderWidth + i * 40 + 20, borderWidth + bannerHeight);
                frameCtx.stroke();
            }
            
            // TechFest logo text
            frameCtx.textAlign = 'left';
            frameCtx.textBaseline = 'middle';
            
            // IEEE text
            frameCtx.fillStyle = '#c0ff00';
            frameCtx.font = `bold ${Math.max(24, h * 0.04)}px Arial`;
            frameCtx.fillText('IEEE', borderWidth + 20, borderWidth + bannerHeight/3);
            
            // TECHFEST text
            frameCtx.fillStyle = '#ffffff';
            frameCtx.font = `bold ${Math.max(32, h * 0.055)}px Arial`;
            frameCtx.fillText('TECHFEST', borderWidth + 20, borderWidth + bannerHeight * 0.65);
            
            // SRI LANKA text
            frameCtx.fillStyle = '#c0ff00';
            frameCtx.font = `bold ${Math.max(16, h * 0.028)}px Arial`;
            frameCtx.fillText('SRI LANKA', borderWidth + 270, borderWidth + bannerHeight * 0.65);
            
            // Bottom tagline
            const bottomY = h - borderWidth - 35;
            frameCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            frameCtx.fillRect(borderWidth, bottomY - 10, w - borderWidth * 2, 50);
            
            frameCtx.fillStyle = '#ffffff';
            frameCtx.font = `${Math.max(14, h * 0.022)}px Arial`;
            frameCtx.textAlign = 'center';
            frameCtx.fillText("Powering Tomorrow's Innovation Through Strategic Partnerships", w/2, bottomY + 15);
            
            // Corner decorations
            const cornerSize = 30;
            frameCtx.strokeStyle = '#c0ff00';
            frameCtx.lineWidth = 4;
            
            // Top corners
            drawCorner(borderWidth + 15, borderWidth + 15, cornerSize, 'top-left');
            drawCorner(w - borderWidth - 15, borderWidth + 15, cornerSize, 'top-right');
            
            // Bottom corners
            drawCorner(borderWidth + 15, h - borderWidth - 15, cornerSize, 'bottom-left');
            drawCorner(w - borderWidth - 15, h - borderWidth - 15, cornerSize, 'bottom-right');
        }
        
        function drawCorner(x, y, size, position) {
            frameCtx.beginPath();
            switch(position) {
                case 'top-left':
                    frameCtx.moveTo(x + size, y);
                    frameCtx.lineTo(x, y);
                    frameCtx.lineTo(x, y + size);
                    break;
                case 'top-right':
                    frameCtx.moveTo(x - size, y);
                    frameCtx.lineTo(x, y);
                    frameCtx.lineTo(x, y + size);
                    break;
                case 'bottom-left':
                    frameCtx.moveTo(x, y - size);
                    frameCtx.lineTo(x, y);
                    frameCtx.lineTo(x + size, y);
                    break;
                case 'bottom-right':
                    frameCtx.moveTo(x - size, y);
                    frameCtx.lineTo(x, y);
                    frameCtx.lineTo(x, y - size);
                    break;
            }
            frameCtx.stroke();
        }
        
        function setFilter(filter, element) {
            currentFilter = filter;
            
            // Update button states
            document.querySelectorAll('.filter-item').forEach(item => {
                if (item.querySelector('.filter-name').textContent !== 'Cap' && 
                    item.querySelector('.filter-name').textContent !== 'Frame') {
                    item.classList.remove('active');
                }
            });
            if (element) {
                element.classList.add('active');
            }
        }
        
        function updateIntensity(value) {
            filterIntensity = value / 100;
            document.getElementById('intensityValue').textContent = value + '%';
        }
        
        function toggleFrame(show, element) {
            showFrame = !showFrame;
            
            if (element) {
                if (showFrame) {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            }
        }
        
        function toggleCap(capType, element) {
            if (showCap === 'techfest') {
                showCap = 'none';
                if (element) element.classList.remove('active');
            } else {
                showCap = 'techfest';
                if (element) element.classList.add('active');
            }
        }
        
        function capturePhoto() {
            // Create a temporary canvas to combine both layers
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            let tempCtx = tempCanvas.getContext('2d');
            
            // Draw the filtered video
            tempCtx.drawImage(canvas, 0, 0);
            
            // Draw the frame overlay if enabled
            if (showFrame) {
                tempCtx.drawImage(frameCanvas, 0, 0);
            }
            
            capturedImage = tempCanvas.toDataURL('image/png');
            
            const previewDiv = document.getElementById('preview');
            previewDiv.className = 'show';
            previewDiv.innerHTML = `
                <h3 style="color: #333;">‚úÖ Photo Captured!</h3>
                <img src="${capturedImage}" alt="Captured">
            `;
            
            document.getElementById('downloadBtn').style.display = 'inline-block';
        }
        
        function downloadPhoto() {
            let link = document.createElement('a');
            link.download = `techfest-${Date.now()}.png`;
            link.href = capturedImage;
            link.click();
        }
        
        // Initialize
        loadFaceDetection();
        startCamera();
    </script>
</body>
</html>
